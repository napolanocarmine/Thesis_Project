# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/05_voxelmap.ipynb (unless otherwise specified).

__all__ = ['make_cube', 'VoxelMap', 'DARTS_TO_2_SEW', 'DARTS_TO_3_SEW']

# Cell
from .gmaps import nGmap
from .pixelmap import PixelMap

import numpy as np

# Cell

# darts of 12 edges to be sewn when constructing cube from squares
#      0  2  4  6 24 26 28 30  8 12 32 36
#     43 39 19 11 47 15 23 35 45 17 41 21

DARTS_TO_2_SEW = np.fromstring ("""
     0  2  4  6    24 26 28 30   10 18 39 47
     9 40 32 17    12 45 37 20   23 34 42 15
""", sep=' ', dtype=np.uint8).reshape ((2,12)).T


# darts to be 3-sewn, when linking voxels, along axis 0, 1, and 2
# DARTS_TO_3_SEW = [[21, 40], [8, 33], [0, 25]]
DARTS_TO_3_SEW = [[24,0], [32,8], [40,16]]


def make_cube():
    six_squares = PixelMap.from_shape(1, 6, sew=False)
    # make a 3-gMap out of 2-gMap, adding the identity involution
    array_4x48 = np.vstack((np.array(six_squares), np.arange(48)))

    cube = nGmap.from_alpha_array(array_4x48)

    for d1, d2 in DARTS_TO_2_SEW:  # iterate over 2-tuples of darts to 2-sew, see image
        cube.sew_no_assert(d1, d2, 2)
    return cube


class VoxelMap (nGmap):
    @property
    def n_slices (self):
        return self._nS

    @property
    def n_columns (self):
        return self._nC

    @property
    def n_rows (self):
        return self._nR

    @classmethod
    def from_shape (cls, n_slices, n_rows, n_columns, sew=True, bounded=True):
        """Constructs grid-like gmap from number slices, rows and columns

        Args:
            n_slices: number of slices
            n_rows: number of rows
            n_columns: number of columns
            sew: sew the pixels together (default) or not?
            bounded: set to False to add the outer boundary

        Returns:
            3-gMap representing a voxel array
        """

        cube = make_cube()

        # step 1: replicate the cube n_slices*n_rows*n_columns times with dart increments of 48
        big_array = np.tile(np.array(cube), n_slices * n_rows * n_columns)
        big_array = big_array.reshape((4, n_slices * n_rows * n_columns, 48))
        for i_cube in range(n_slices * n_rows * n_columns):
            big_array[:, i_cube] += 48 * i_cube
        big_array = big_array.reshape((4, -1))

        # make a gmap consisting of n_slices * n_rows * n_columns cubes
        vox_map = cls.from_alpha_array(big_array)
        vox_map._nS, vox_map._nR, vox_map._nC = n_slices, n_rows, n_columns

        if sew:  # 3-sew the cubes
            # column-wise 3-sews
            dart_to_sew_1st, dart_to_sew_2nd = DARTS_TO_3_SEW[2]
            for s in range(n_slices):  # for all Slices
                for r in range(n_rows):  # for all Rows
                    for c in range(n_columns - 1):  # for all Columns but last one
                        vox_map.sew_no_assert(
                            48 * (s * n_rows * n_columns + r * n_columns + c) + dart_to_sew_1st,
                            48 * (s * n_rows * n_columns + r * n_columns + c + 1) + dart_to_sew_2nd,
                            3)

            # row-wise 3-sews
            dart_to_sew_1st, dart_to_sew_2nd = DARTS_TO_3_SEW[1]
            for s in range(n_slices):  # for all Slices
                for r in range(n_rows - 1):  # for all Rows but last one
                    for c in range(n_columns):  # for all Columns
                        vox_map.sew_no_assert(
                            48 * (s * n_rows * n_columns + r * n_columns + c) + dart_to_sew_1st,
                            48 * (s * n_rows * n_columns + (1 + r) * n_columns + c) + dart_to_sew_2nd,
                            3)

            # slice-wise 3-sews
            dart_to_sew_1st, dart_to_sew_2nd = DARTS_TO_3_SEW[0]
            for s in range(n_slices - 1):  # for all Slices but last one
                for r in range(n_rows):  # for all Rows
                    for c in range(n_columns):  # for all Columns
                        vox_map.sew_no_assert(
                            48 * (s * n_rows * n_columns + r * n_columns + c) + dart_to_sew_1st,
                            48 * ((1 + s) * n_rows * n_columns + r * n_columns + c) + dart_to_sew_2nd,
                            3)

        if not bounded:  # TODO implement the shell darts for an unbounded map
            raise NotImplemented

        assert vox_map.is_valid

        return vox_map